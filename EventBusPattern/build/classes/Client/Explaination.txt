### Data/Event Bus Pattern - Overview (Example with Components and Classes)

#### Intent: 
The Data Bus Pattern aims to facilitate communication between different components or systems by providing a centralized mechanism for data exchange. 
    It allows various parts of an application to communicate asynchronously and decouples the sender and receiver components, promoting a more modular architecture.
    [many-to-many]

#### Scenario:
You are building a student support system for an online learning platform. When a student submits a message requesting help with an assignment, 
    this message needs to be received and processed by multiple components of the system: the database, the user interface (GUI), and network services. 
    Each component is responsible for a different task, such as logging the message, displaying it to support staff, or forwarding it to an external service.
    However, you want to avoid tight coupling between these components to ensure scalability, maintainability, and flexibility as the system grows.

---

#### Problem:
In tightly coupled systems, where one component needs to know about other components to send or receive data, adding new features or components becomes difficult. 
    For example, if Component A (Database) is directly aware of Component B (GUI) and Component C (Network Services), 
    adding a new component would require modifying Component A, as well as all other components that need to communicate with the new component.
    This leads to code duplication, a complex and hard-to-maintain system, and reduced flexibility. 
    We need a design where components can respond to events (such as a new student message) independently without knowing about each other.

---

#### Solution: Event Bus Pattern
The Event Bus Pattern solves this problem by introducing a centralized bus where components can publish and subscribe to events. 
    Instead of Component A, B, and C directly communicating with each other, they subscribe to an EventBus. 
    When a new message (represented as an event) is submitted, it is broadcasted to all subscribers.
    In this way, the system becomes loosely coupled. 
    Components can subscribe to the bus to receive events and can publish their own events without knowing who is subscribing to them. 
    If we want to add new components in the future, such as a notification system, we can simply subscribe the new component to the event bus without modifying existing components.

---

### Explanation:
1. Event Publisher (StudentMessage): 
   - The `StudentMessage` class represents an event, such as a student submitting a help request message. 
        It contains details like the student’s name and message content.

2. Event Bus:
   - The `EventBus` acts as a communication hub between components. When the student submits a message, it is published on the `EventBus`. 
        All subscribed components (database, GUI, network services) will receive the event and handle it independently.

3. Components (Subscribers):
   - Component A (Database Connection): Logs the student’s message into the database for future reference.
   - Component B (GUI): Displays the message on the user interface for support staff to read.
   - Component C (Network Services): Forwards the message to external systems or sends an alert to other services.

4. Main Class (Subscription):
   - In the main class, each component subscribes to the `EventBus`. When the `StudentMessage` is published, all the subscribers (Components A, B, and C) are notified and handle the event in their own way.

---

### Benefits of Event Bus Pattern:

1. Loose Coupling:
   - Components don’t need to know about each other. They only interact with the `EventBus`, making it easier to add, remove, or modify components without impacting others.
   
2. Scalability:
   - New components can be added to the system by simply subscribing to the `EventBus`, without requiring changes to existing components.

3. Maintainability:
   - The system is easier to maintain and modify because the event-handling logic is decoupled from the event-publishing logic.

4. Reusability:
   - The `EventBus` can be reused for other types of events, not just student messages. This makes the architecture more flexible for future growth.

5. Simplified Communication:
   - The pattern simplifies communication between multiple components by centralizing it through the `EventBus`, which reduces the number of dependencies between components.

---

#### Conclusion:

The Event Bus Pattern is a powerful design for decoupling components in systems that need to handle events. 
    In our scenario, it allows the database, GUI, and network services to respond to student messages without needing to know about each other. 
    This leads to a more flexible, scalable, and maintainable system. The ability to add new components, like a notification system, 
    without modifying existing ones showcases the strength of this pattern in managing complex event-driven architectures.

-------------------------------------------------------------------------------
Try to add a new component and see how its easy to use.

In the End: This Pattern is so Important, its used so much.


Why all of the 3 classes in one file?? can i seperate them ??
Yes, you can. But this way is better; because if you needed the file to another project, you will take it all in one file.

Why EventBus Class in one package??
to make it Reusabe.


------------------------------------------------------------------------------- Explanation Code
```java

public class EventBus {

    // Singleton pattern: ensures only one instance of EventBus is created.
    private static EventBus instance = null;

    // List of subscribers that have subscribed to the event bus.
    protected List<Subscriber> subscribers = new ArrayList<>();

    // Private constructor to prevent external instantiation (Singleton pattern).
    private EventBus() {
    }

    // Provides global access to the single instance of EventBus.
    // Synchronized to make it thread-safe.
    public static synchronized EventBus getInstance() {
        if (instance == null) {
            instance = new EventBus(); // Create a new instance if not already created.
        }
        return instance;
    }

    // Method to subscribe a new Subscriber to the event bus.
    public void subscribe(Subscriber subscriber) {
        // Adds the subscriber only if it's not already present in the list.
        if (!subscribers.contains(subscriber)) {
            subscribers.add(subscriber);
        } else {
            // If already subscribed, notify the user.
            System.out.println("subscriber is already registered !!");
        }
    }

    // Method to unsubscribe a Subscriber from the event bus.
    public void unSubscribe(Subscriber subscriber) {
        // Removes the subscriber only if it's found in the list.
        if (subscribers.contains(subscriber)) {
            subscribers.remove(subscriber);
        } else {
            // If subscriber is not found, notify the user.
            System.out.println("subscriber is not found !!");
        }
    }

    // Method to notify all subscribers when a message (BusMSG) is sent.
    public void notifySubscribers(BusMSG msg) {
        // Loops through the list of subscribers to notify each one.
        for (Subscriber subscriber : subscribers) {
            // Check if the subscriber is not the sender itself to avoid self-notification.
            if (!subscriber.equals(msg.getSender())) {
                subscriber.msgReceived(msg); // Notify the subscriber with the message.
            }
        }
    }

    // Interface defining what each subscriber must implement.
    public interface Subscriber {

        // Method to handle receiving a message from the event bus.
        public void msgReceived(BusMSG msg);

        // Method to send a message to other subscribers.
        public void sendToOthers(StudentMSG msg);
    }

    // Static abstract class that serves as a base for all messages (BusMSG).
    // static => to make StudentMSG access to this class.
    // This Class to unify all valuesType [int ,float ,string ,...so on] from senders.
    public static abstract class BusMSG {
        // 'sender' refers to the subscriber that sent the message (publisher).
        protected Subscriber sender; // Can be any of A, B, C, ...

        // Returns the subscriber that sent the message.
        public Subscriber getSender() {
            return sender;
        }

        // Sets the sender of the message.
        public void setSender(Subscriber sender) {
            this.sender = sender;
        }
    }
}

/*
Event Bus [
1. Interface Subscriber defines the methods for receiving and sending messages.
2. Static abstract class BusMSG acts as a base for messages and manages the sender info.
3. The EventBus class maintains a list of subscribers and provides methods to subscribe, 
   unsubscribe, and notify all subscribers of new messages.
4. The EventBus class is implemented as a Singleton to ensure only one instance exists.
]
*/
```

### Explanation of the Comments:
1. **Singleton Pattern**: Explained why and how the class ensures only one instance of `EventBus`.
2. **Subscriber Methods**: Each method (`subscribe`, `unsubscribe`, and `notifySubscribers`) is clearly commented on its role and logic.
3. **Subscriber Interface**: Defined the required methods for any subscriber implementing this interface.
4. **BusMSG Abstract Class**: Clarified that it's used to generalize all message types and manage the sender of the message.


-------------------------
```java
        if (msg instanceof StudentMSG) {
            StudentMSG sm = (StudentMSG) msg;
```

1. msg instanceof StudentMSG:

This checks whether the msg object is an instance of the StudentMSG class.
In Java, instanceof is a keyword used to check whether an object is of a specific type or subclass.
If the condition is true, it means that msg is an instance of StudentMSG or a subclass of it.

2. StudentMSG sm = (StudentMSG) msg;:

This is casting. Once the instanceof check passes, we are safely casting the msg object to the StudentMSG type.
After casting, we can assign the object to a variable (sm) of type StudentMSG and use it with all the properties and methods specific to the StudentMSG class.